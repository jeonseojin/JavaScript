
/*  가비지 컬렉션(garbage colloector : 쓰레기 수집)
        - 메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능
        - 동적 할당된 메모리 영역 가운데 어떤 변수도 가리키지 않는 메모리 영역을 탐지하여 자동으로 해제하는 기법
            자바스크립트 엔진 내에선 가비지 컬렉터(garbage collector)가 끊임없이 동작
            모든 객체를 모니터링하고, 도달할 수 없는 객체는 삭제

        * 가비지 컬렉션 기준
            - 자바스크립트는 도달 가능성(reachability)이라는 개념을 사용해 메로리 관리를 수행
                ※ 도달 가능성(reachability) 값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미
                ※ 도달 가능한 값은 메모리에서 삭제되지 않음
            
            1. 태생부터 도달 가능하기 때문에 삭제되지 않는 것
                - 현재 함수의 지역 변수와 매개변수
                - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
                - 전연 변수
                - 기타

            2. 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값
                (전역 변수에 객체가 저장되어있다고 가정, 이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면 프로퍼티가 참조하는 객체는 도달 가능한 값이 됨
                이 객체가 참조하는 다른 모든 것들도 도달 가능하다고 여겨짐)

                
                    
                        let user = { 
                            name: "John"
                        };
                    -> user엔 객체 참조 값이 저장, John의 프로퍼티 "name"은 원시값을 저장하고 있기 때문에 객체 안에 표현
                        
                        user = null;
                    -> user의 null로 덮으면 John은 도달할 수 없는 상태로 바뀜, John에 저장된 데이터를 삭제하고, John을 메모리에서 삭제
        
        * 참조 두 개 (참조를 user에서 admin으로 복사했다고 가정)
            
                        
                        let user = {
                            name: "John"
                        };
                    -> user엔 객체 참조 값이 저장

                        let admin = user;
                        user = null;
                    -> 전역 변수 admin을 통하면 여전해 객체 John에 접근할 수 있기 때문에 John은 메모리에서 삭제되지 않음
                    -> 이 상태에서 admin은 다른 값(null 등)으로 덮어쓰면 John은 메모리에서 삭제될 수 있다.

        * 연결된 객체

                        function marry(man, woman) {
                            woman.husband = man;
                            man.wife = woman;
                            return {
                                father: man,
                                mother: woman
                            }
                        }

                        let family = marry({
                            name: "John"
                        }, {
                            name: "Ann"
                        });
                    -> 함수 marray는 매개변수로 받은 두 객체를 서로 참조하게 하면서 결혼시키고, 두 객체를 포함하는 새로운 객체를 반환
                            ※ object-> name: "Ann"
                                            ↑↓
                               object-> name: "John"  

                        delete family.father;
                    -> 모든 객체가 여전히 도달 가능한 상태(John -> Ann : husband로 연결)
                            ※ object-> name:"Ann" 
                                            ↑↓
                               object   name: "John" 


                        delete family.mother.husband;
                    -> 참조 두 개를 모두 지우면 John으로 들어오는 참조는 모두 사라져 John은 도달 가능한 상태에서 벗어남
                    -> John이 Ann과 wife로 연결은 되어 있지만 Ann은 John과 연결되어 있는 것이 아니므로 도달 가능한 상태가 아니기 때문에 메모리 제거
                            ※ object-> name:"Ann" 
                                            ↑
                               object   name: "John" 

        * 도달할 수 없는 섬 : 객체들이 연결되어 섬 같은 구조를 만드는데, 이 섬에 도달할 방법이 없는 경우, 섬을 구성하는 객체 전부가 메모리에서 삭제
            - 근원 객체 family가 아무것도 참조하지 않도록 설정

                    family = null;

                              name:"Ann" 
                    object        ↑↓
                              name: "John"

                -> 두 객체 모두 외부에서 들어오는 참조를 갖고 있지만,"family" 객체와 루트의 연결이 사라지면 루트 객체를 참조하는 것이 아무것도 없다
                -> 섬 전체가 도달할 수 없는 상태가 되고, 섬을 구성하는 객체 전부가 메모리에서 제거된다.
                    
        * 내부 알고리즘
            - 'mark-and-sweep’이라 불리는 가비지 컬렉션 기본 알고리즘
                ※ 가비지 컬렉션의 평균적인 수행 순서
                    - 가비지 컬렉터는 루트(root) 정보를 수집하고 이를 mark(기억) 함
                    - 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark 함
                    - mark 된 모든 객체에 방문, 그 객체들이 참조하는 객체도 mark 함, 한 번 방문한 객체는 전부 mark 하기 때문에
                      같은 객체를 다시 방문하는 일은 없음
                    - 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복
                    - mark 되지 않은 모든 객체를 메모리에서 삭제

            - 가비지 컬렉션이 어떻게 동작하는지에 대한 개념
                ※ 최적화 기법 :
                    - generational collection(세대별 수집) : 객체를 '새로운 객체’와 '오래된 객체’로 나눔, 객체 상당수는 생성 이후 제 역할을 빠르게
                                수행해 금방 쓰모가 없어지는데, 이런 객체를 새로운 객체로 구분. 가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거
                                일정한 시간 이상 동안 살아남은 객체는 오래된 객체로 분류하고 가비지 컬렉터가 덜 감시

                    - incremental collection(점진적 수집) : 방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark하는데 상당한 시간이 소모
                                가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려짐, 자바스크립트 엔진은 이런 현상을 개선하기 위해
                                가비지 컬렌션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행
                                작업을 분리하고 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연은 짧은 지연 여러개로 분산시킬 수 있는 장점이 있음

                    - idle-time collection(유휴 시간 수집) : 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행


        ※ 요약
            - 가비지 컬렉션은 엔진이 자동으로 수행하므로 개발자는 이를 억지로 실행하거나 막을 수 없음
            - 객체는 도달 가능한 상태일 때 메모리에 남음
            - 참조된다고 해서 도달 가능한 것은 아님, 서로 연결된 객체들도 도달 불가능할 수 있음




*/