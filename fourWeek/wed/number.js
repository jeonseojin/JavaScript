
// 과제1) 수를 입력받아 덧셈하기 : 사용자에게 두 수를 입력받고 두 수의 합을 출력해주는 스크립트를 작성해보세요

let a = +prompt('더할 숫자를 입력하세요', '');
let b = +prompt('더할 숫자를 입력하세요', '');
alert((a+b));

/*  과제2) 6.35.toFixed(1) == 6.3인 이유는 무엇일까요?
    - Math.round와 toFixed는 둘 다 가장 가까운 어림수를 구해줌
    - 0..4는 버림, 5..9는 올림
            alert( 1.35.toFixed(1) );

    6.35가 6.4가 아닌 6.3으로 반올림 되는 이유가 무엇인가
*/
alert( ((6.35*10).toFixed(1))/10);

/*  과제3) 숫자를 입력할 때까지 반복하기
        - 사용자가 유효한 숫자형 값을 입력할 때까지 계속 입력받은 함수 readNumber를 만들어보기
          반환되는 값은 꼭 숫자형 값이어야 함
          사용자가 아무 입력도 하지 않거나 취소를 누르면 입력받기를 멈추고 null을 반환
*/
 let c;
 do{
        c = +prompt('숫자를 입력하세요', '');

 }while(!isFinite(c)); 
 alert("read: "+c);

 /* 과제4) An occasional infinite loop(가끔 무한 루프)

                let i = 0;
                    while (i != 10) {
                    i += 0.2;
                }
            -> 이 무한 루프는 왜 끝나지 않는지?
            부정확한 계산으로 인해 
            2진수로 변환할 경우 순환소수가 발생하게 되는데 부동소수점으로 변환하려면 소수점을 옮겨야 함
            (이 경우 값이 정확하지 않고 근사 값으로 계산을 하기 때문에 오차가 나오는 상황이 발생)

 */

/*  과제5) A random number from min to max(최소에서 최대까지 임의의 숫자)
            - 내장 함수 Math.random()는에서 0to 까지 임의의 값을 생성
            - random(min, max)에서 min to 까지 임의의 부동 소수점 숫자를 생성하는 함수를 작성

*/
function random(min, max) {
    return min + Math.random() * (max - min);
}
alert( random(1, 5) );
alert( random(1, 5) );
alert( random(3, 5) );


/*  과제6) A random integer from min to max(최소에서 최대까지 임의의 정수)
        - 함수 생성 randomInteger(min, max)랜덤 생성 정수 의 숫자 min를 max모두 포함 min하고 max있는 값
*/ 
function randomInteger(min, max) {
    let ran = min + Math.random() * (max +1 - min);
    return Math.floor(ran);// 소수점에서 버림을 하여 정수를 출력
}
alert( randomInteger(1, 5) );
alert( randomInteger(1, 5) );
alert( randomInteger(3, 5) );

/*  숫자형
        1. 일반적인 숫자는 배정밀도 부동소수점 숫자(double precision floating point number)로 알려진 64비트 형식의 IEEE-754에 저장
        2. 임의의 길이를 가진 정수는 BigInt 숫자, 일반적인 숫자는 2의 53승 이상이거나 -2의 53 이하일 수 없다는 제약 때문에 BigInt라는
           새로운 자료형이 만들어짐, BigInt는 아주 특별한 경우에만 사용됨

    숫자를 입력하는 다양한 방법

                    let billion = 1000000000;
            
                -> 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에 실제로는 이런 방법을 잘 사용하지 않음
                   10억을 표현 할때는 1bn을 사용, 73억일 경우 7.3bn을 사용

                     let billion = 1e9; -> 1과 9개의 0으로 이루어진 10억을 의미
                     alert(7.3e9); -> 73억

                -> JS에서는 숫자 옆에 e를 붙이고 0의 개수를 그 옆에 붙여주는 형태로 사용
                ->  e 왼쪽의 수에 e 오른쪽의 수만큼의 10의 거듭제곱을 곱하는 효과
                        1e3 = 1 * 1000
                        1.23e6 = 1.23 * 1000000


                    let ms = 0.000001; -> let ms = 1e-6;
                -> 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현
                -> 1에서 왼쪽으로 6번 소수점 이동, e 우측에 음수가 있으면 이 음수의 절댓값 만큼 10을 거듭제곱한 수로 나누는 것을 의미
                        1e-3 = 1 / 1000 (=0.001)                -> 10을 세 번 거듭제곱한 수로 나눔
                        1.23e-6 = 1.23 / 1000000 (=0.00000123)  -> 10을 여섯 번 거듭 제곱한 수로 나눔

    16진수, 2진수, 8진수
        - 16진수 : 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰임, 16진수는 0x를 사용해 표현
                        alert(0xff); -> 255
                        alert(0xFF); -> 255
                    -> 대·소문자를 가리지 않아서 같은 값을 나타냄

        - 2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 0b와 0o를 사용해서 간단하게 나타낼 수 있음
                        let a = 0b11111111; -> 255의 2진수
                        let b = 0o377;      -> 255의 8진수
                        alert(a == b); 
                    -> 진법은 다르지만 a와 b는 같은 수를 나타내어 true를 출력

        - JS에서 지원하는 진법은 3개이며 이 외의 진법을 사용하려면 함수 parseInt를 사용해야 한다.

    toString(base) : num.toString(base) 메서드는 base진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환

                        let num = 255;
                        alert(num.toString(16));    -> 16진수의 255는 ff
                        alert(num.toString(2));     -> 2진수의 255는 11111111
                    -> base는 2에서 36까지 사용 가능, 기본값은 10

        * base별 유스 케이스
            - base=16 : 16진수 색, 문자 인코딩 등을 표현할 때 사용, 숫자는 0부터 9, 10이상의 수는 A부터 F를 사용
            - base=2  : 비트 연산 디버깅에 주로 사용, 숫자는 0 또는 1을 사용
            - base=36 : 사용할 수 있는 base 중 최댓값으로 0..9와 A..Z를 사용해서 숫자를 표현, 알파벳 전체가 숫자를 나태내는 데 사용
                        36 base는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용

                            lert(123456..toString(36));
                        -> 123456의 36진수 2n9c가 출력

                    ※ 점 두 개와 메서드 호출
                        - 123456..toString(36)에 있는 점 두 개는 오타가 아님, 숫자를 대상으로 메서드 toString을 직접 호출하고 싶다면 숫자 다음에
                          점 두 개 .. 를 붙여야 한다.
                        - 123456.toString(36)처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생
                          점을 하나 더 추가하면 JS는 소수부가 없다고 판단하고 함수를 호출
                        - (123456).toString(36)로도 가능

    어림수 구하기
        - 어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나
        ※ 관련 내장 함수 알아보기
            - Math.floor : 소수점 첫째 자리에서 내림(버림), 3.1은 3, -1.1은 -2가 됨
            - Math.ceil  : 소수점 첫째 자리에서 올림, 3.1은 4, -1.1은 -1이 됨
            - Math.round : 소수점 첫째 자리에서 반올림, 3.1은 3, 3.6은 4, -1.1은 -1이 됨 
            - Math.trunc : 소수부를 무시, 3.1은 3, -1.1은 -1이 됨(internet Ecplorer에서는 지원하지 않음)

        - 위의 내장 함수들만으로도 소수부에 관련된 연산 대부분을 처리 가능
        
        - 소수점 n-th번째 수를 기준으로 어림수를 구해야 하는 경우(ex: 1.2345가 있는데 소수점 두 번째 자릿수까지만 남겨 1.23을 만들고 싶은 경우)
            1. 곱하기 나누기
                - 소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후 원하는 어림수 내장 함수를
                  호출하고 처음 곱한 수를 다시 나눔
                
                        let num = 1.23456;
                        alert(Math.floor(num*100)/100);
                    -> 1.23456 -> 123.456-> 123 -> 1.23 의 과정

            2. 소수점 n번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 toFixed(n)를 사용

                        let num = 12.34;
                        alert(num.toFixed(1));
                    -> toFixed는 Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림을 하여 12.3를 출력
                        let num = 12.36;
                        alert(num.toFixed(1));
                    -> 위의 설명과 동일하게 적용되어 12.4를 출력
                        let num = 12.34;
                        alert(num.toFixed(5));
                    -> 소수부의 길이를 5로 만들기 위해 0이 추가되어 12.34000으로 출력
                    -> (참고)+num.toFixed(5)처럼 단항 덧셈 연산자를 앞에 붙이거나 Number()를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있다.

    부정확한 계산(참고 : https://bigtop.tistory.com/47)
        - 숫자는 64비트가 필요(64비트 중 52비트는 숫자를 저장, 11비트는 소수점 위, 1비트는 부호를 저장), 숫자가 너무 커지면
          64비트 공간이 넘쳐서 Infinity로 처리됨

                        alert(1e500); -> Infinity
                        alert(0.1 + 0.2 == 0.3); -> false(0.30000000000000004의 결과가 나와서 0.3과는 다르다고 판단...)

        - 컴퓨터로 숫자를 표현하는 데에는 한계, 10진수로 표현되는 소수를 2진수로 표현하려면 몇몇의 경우 무한소수가 발생
          무한수를 유한하게 표현하려다 보니 미세한 값들이 초과되거나 손실되어 계산 오류가 발생

            ※ 해결 방안
                * toFixed() 메서드를 사용하여 어림수를 만드는 것
                        let a = 0.1;
                        let b = 0.2;
                        alert((a+b).toFixed(1)); -> '0.3'
                    -> toFixed 메서드는 파라미터로 0부터 20까지 숫자를 넘길 수 있는 데 해당 값이 소수점 이후의 자릿수를 결정
                       하지만 반환되는 값이 문자열이기 때문에 만일 숫자로 사용하고 싶다면 앞에 단항 연산자로 덧셈 연산자를 붙여주어야 함

                        alert(+(a+b).toFixed(1)); -> 0.3

                * Math 객체의 메서드 활용

                        alert(Math.round((a+b)*10) /10); -> 0.3

                    -> Math 객체에 Math.floor, Math.ceil, Math.trunc, Math.round 같은 소수를 다루는 메서드들을 통해 연산하고자 하는 의도에
                       따라 계산을 하는 방법

                * 라이브러리 활용
                    - 자바스크립트용 수학 라이브러리를 사용하는 것
                    - Big.js, BigNumber.js, Decimal.js, mathjs 등 라이브러리를 활용하면 좀 더 안전하게 수학 계산을 할 수 있기도 함
                        (라이브러리를 활용하는 방법은 불편할 수도 있음)

        ※ alert(9999999999999999); -> 10000000000000000이 출력
            - 문제의 원인은 정밀도 손실, 숫자를 저장할 땐 64비트가 사용됨, 이 중 실제 숫자를 저장하는 데 사용되는 52비트에 위 숫자를 저장하기엔 공간이 모자름
              따라서 최소 유효 숫자(the least significant digit)가 손실되어 버림
        ※ 두 종류의 0
            - JS 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 0과 -0이라는 두 종류의 0이 존재한다는 사실
            - JS에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하 않을 수도 있기 때문
            - 대부분의 연산은 0과 -0을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는 편

    isNaN과 isFinite
        - 두 특수 숫자 값
            * Infinity와 -Infinity : 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
            * NaN : 에러를 나타내는 값
            
        - 두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에 정상적인 숫자와 구분하기 위한 특별한 함수가 존재

            * isNaN(value) : 인수를 숫자로 변환한 다음 NaN인지 테스트함
            
                    alert(isNaN(NaN)); -> true
                    alert(isNaN("str")); -> true
                -> NaN은 NaN 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특

                    alert(NaN === NaN); -> false
                
            * isFinite(value) : 인수를 숫자로 변환하고 변환한 숫자가 NaN / Infinity / -Infinity가 아닌 일반 숫자인 경우 true를 반환

                    alert(isFinite("15"));      ->true
                    alert(isFinite("str"));     -> false, NaN이기 때문
                    alert(isFinite(Infinity));  -> false, Infinity이기 때문
                    

                    let num = +prompt("숫자를 입력하세요.", '');
                    alert(isFinite(num));
                -> isFInite는 문자열이 일반 숫자인지 검증하는 데 사용되곤 함
                -> 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력
                
        - 빈 문자열이나 공백만 있는 문자열은 isFinite를 포함한 모든 숫자 관련 내장 함수에서 0으로 취급된다는 점에 유의

            ※ Object.is 와 비교하기
                - Object.is는 === 처럼 값을 비교할 때 사용되는 특별한 내장 메서드, 아래와 같은 두 가지 에지 케이스에선 ===보다 좀 더 신뢰할만한 결과를 보여줌

                    1. NaN을 대상으로 비교할 때 : Object.is(NaN, NaN) === true
                    2. 0과 -0이 다르게 취급되어야 할 때 : Object.is(0, -0) === false,
                       숫자를 나타내는 비트가 모두 -이더라도 부호를 나타내는 비트는 다르므로 0과 -0은 사실 다른 값이다.

                - 이 두 에지 케이스를 제외하곤, Object.is(a, b)와 a === b의 결과

    parseInt와 parseFloat : 단항 덧셈 연산자 + 또는 Number()를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격, 피연산자가 숫자가 아니면 형 변환이 실패

                        alert( + "100px"); -> NaN
                    -> 엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때 발생

            - parseInt는 정수, parseFloat는 부동 소수점 숫자를 반환

                        alert(parseInt('100px'));       -> 100
                        alert(parseFloat('12.5em'));    -> 12.5
                        alert(parseInt('12.3));         -> 12(정수 부분만 반환)
                        alert(parseFloat('12.3.4'));    -> 12.3(두 번째 점에서 숫자 읽기를 멈춤)

                        alert( parseInt('a123') );
                    -> parseInt와 parseFloat가 NaN을 반환할 때도 있음, 읽을 수 있는 숫자가 없을 때
                    -> a는 숫자가 아니므로 숫자를 읽는 게 중지되어 NaN을 출력

            ※ parseInt(str, radix)의 두 번째 인수
                - parseInt()의 두 번째 매개 변수는 선택적으로 사용 가능, radix는 원하는 진수를 지정해 줄 때 사용, parseInt를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱

                        alert(parseInt('0xff', 16));        -> 255
                        alert(parseInt('ff', 16));          -> 255 : 0x가 없어도 동작 
                        alert(parseInt('2n9c', 36));        -> 123456


    기타 수학 함수
        - JS에서 제공하는 내장 객체 Math엔 다양한 수학 관련 함수와 상수들이 들어있다.

            * 예시 살펴보기
                - Math.random() : 0과 1사이의 난수를 반환(1은 제외)

                        alert(Math.random()); -> 0.123456789456
                        alert(Math.random()); -> 0.654987321465 등의 무작위 수

                - Math.max(a, b, c...) / Math.min(a, b, c...) : 인수 중 최대 / 최솟값을 반환

                        alert(Math.max(2,3,6,7,4,-10,1));   -> 7
                        alert(Math.min(1,5));               -> 1

                - Math.pow(n,power) : n을 power번 거듭제곱한 값을 반환

                        alert(Math.pow(2,10));  -> 2의 10제곱 = 1024

                # 이 외에도 삼각법을 포함한 다양한 함수와 상수가 Math에 있음

    ※ 요약
        - 0이 많이 붙은 큰 숫자를 사용하는 방법
            * 0의 개수를 e 뒤에 추가, 123e6은 0이 6개인 숫자, 123000000을 나타냄
            * e 다음에 음수가 오면 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눔
              123e-6은 0.000123을 나타냄
        
        - 다양한 진법을 사용 가능
            * 자바스크립트는 특별한 변환 없이 16진수(0x), 8진수(0o), 2진수(0b)를 바로 사용할 수 있게 지원
            * parseInt(str, base)를 사용하면 str을 base진수로 바꿔줌(단, 2 ≤ base ≤ 36)
            * num.toString(base)는 숫자를 base진수로 바꾸고, 이를 문자열 형태로 반환
            * 
        - 12pt나 100px과 같은 값을 숫자로 변환하는 것도 가능 
            * parseInt/parseFloat를 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 ‘약한’ 형 변환을 사용가능

        - 소수를 처리하는 데 쓰이는 메서드
            * Math.floor, Math.ceil, Math.trunc, Math.round, num.toFixed(precision)를 사용하면 어림수를 구할 수 있음
            * 소수를 다룰 땐 정밀도 손실에 주의
        
        - 이 외에도 다양한 수학 함수가 있음
            * 수학 연산이 필요할 때 Math 객체를 사용해 보기, 작은 객체이지만 기본적인 연산은 대부분 다룰 수 있음




*/
