"use strict";
/* 과제1) 문자열에 프로퍼티를 추가할 수 있을까요?
    
    코드를 실행하였을 때 의도한 대로 문자열(str)에 프로퍼티(test)를 추가 가능 여부, 만약 가능하다면 alert창에 출력되는 것
    "use strict";를 사용하지 않은 경우 undefined가 출력
    "use strict";를 사용한 경우 에러 발생으로 출력되지 않음
*/
let str = "Hello";
str.test = 5;
/*  1. str의 프로퍼티에 접근하려면 래퍼 객체가 만들어짐
    2. 엄격 모드에선 래퍼 객체를 수정하려 할 때 에러가 발생
    3. 비 엄격 모드에선 에러가 발생하지 않음, 래퍼 객체에 프로퍼티 test가 추가
       래퍼 객체는 바로 삭제되기 때문에 마지막 줄이 실행될 때 프로퍼티 test를 찾을 수 없어서 undefined를 출력하게 되는 것
 */
alert(str.test);

/*  원시값의 메서드
        - JS는 원시값(문자열, 숫자 등)을 마치 객체처럼 다룰 수 있게 해줌, 원시값에도 객체에서처럼 메서드를 호출할 수 있다
        - 원시값과 객체의 차이점
            - 원시값: 원시형 값, 원시형의 종류는 문자(String), 숫자(number), bigint, 불린(boolean), 심볼(symbol), null,
                      undefined형으로 총 일곱 가지이다
            - 객체 : 프로퍼티에 다양한 종류의 값을 저장, {name : "John", age : 30}와 같이 대괄호 {}를 사용해 만들 수 있음,
                     JS에는 여러 종류의 객체가 있는데 함수도 객체의 일종이다.
                     * 객체의 장점 중 하나는 함수를 프로퍼티로 저장할 수 있다는 것

                            let john = {
                                name: "John",
                                sayHi: function() {
                                    alert("친구야 반갑다!");
                                }
                            };
                            john.sayHi();
                        -> 객체 John을 만들어 그 안에 메서드 sayHi를 정의하여 호출 : 친구야 반갑다!

        - JS는 날짜, 오류, HTML 요소(HTML element) 등을 다룰 수 있게 해주는 다양한 내장 객체를 제공
                (이런 기능을 사용하면 시스템 자원이 많이 소모되는 단점이 있음)
        - 객체는 원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문

    원시값을 객체처럼 사용하기
        - JS 창안자(creator)가 해결해야하는 모순적인 상황
            * 문자열이나 숫자와 같은 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각이 듬
            * 원시값은 가능한 빠르고 가벼워야 함

        - JS 창안자가 모색한 해결책
            1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지
            2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용
            3. 이를 가능하게 하기 위해, 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, 원시 래퍼 객체(object wrapper)
               를 만들어 줌(이 객체는 곧 삭제됨(일회성..?))

        * 래퍼 객체 : 원시 타입에 따라 종류가 다양함, 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, String, Number, Boolean, Symbol로 불림
                      래퍼 객체 마다 제공하는 메서드 역시 다름
        
            - 인수로 받은 문자열의 모든 글자를 대문자로 바꿔주는 메서드 str.toUpperCase() 사용

                            let str = "Hello";
                            alert(str.toUpperCase());
                        -> 모든 글자를 대문자로 변경해주는 메서드이기 때문에 HELLO가 출력

                        1. 문자열 str은 원시값이므로 원시값의 프로퍼티(toUpperCase)에 접근하는 순간 특별한 객체가 만들어짐
                           이 객체는 문자열의 값을 알고 있고, toUpperCase()와 같은 유용한 메서드를 가지고 있음
                        2. 메서드가 실행되고, 새로운 문자열이 반환됨(alert창에 이 문자열이 출력)
                        3. 특별한 객체는 파괴되고, 원시값 str만 남음

                    - 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있는 것
                    - JS 엔진은 위 프로세스의 최적화에 많은 신경을 씀, 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성(명세에 언급)한 것처럼
                          동작하게끔 해줌

            - 숫자형의 고유한 메서드, 메서드 toFixed(n)를 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림

                            let n = 1.23456;
                            alert(n.toFixed(2));
                        -> 반올림을 통해서 1.23이 출력

            ※ String / Number / Boolean 를 생성자론 쓰지 말기
                            
                            alert(typeof 0); -> number
                            alert(typeof new Number(0));
                        -> 위의 문법을 사용하면 원하는 타입의 래퍼 객체를 만들 수 있음, object가 출력됨(추천하지 않음)

                            let zero = new Number(0);
                            if(zero){                   -> 변수 zero는 객체임, 조건문이 참이 됨
                                alert("그런데 여러분은 zero가 참이라는 것에 동의하시나요!?!");
                            }
                - new를 붙이지 않고 String / Number / Boolean 을 사용하는 건 괜찮음, new 없이 사용하면 상식에 맞게 인수를 원하는
                  형의 원시값(문자열, 숫자, 불린 값)으로 바꿔줌(아주 유용)

                            let num = Number("123"); -> 문자열을 숫자로 변경해줌
                        
            ※ null / undefined 는 메서드가 없다.
                - 특수 자료형인 null과 undefined의 원시값(null/undefined)은 위와 같은 법칙을 따르지 않음, 이 자료형과 연관되는 래퍼 객체도 없고
                  메서드도 제공하지 않음(어떤 의미에서는 두 자료형이 가장 원시적임)

                            alert(null.test);
                        -> 두 자료형에 속한  값의 프로퍼티에 접근하려 하면 에러가 발생함
               

    Summary
        - null과 undefined를 제외한 원시값에 다양한 메서드를 호출 가능
        - 원시값에 메서드를 호출하려 하면 임시 객체가 만들어짐, JS 엔진은 내부 최적화가 잘 되어있어 메서드를 호출해도 많은 리소스를 쓰지 않음



*/